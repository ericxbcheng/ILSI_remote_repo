---
title: "Sampling Iteration"
author: "Xianbin Cheng"
date: "September 16, 2018"
output: html_document
---

# Method

1. Source R code from `Sampling_libraries.R`, `Sampling_contamination.R`, `Sampling_plan.R` and `Sampling_outcome.R`.

```{r, warning = FALSE, message = FALSE}
source(file = "Sampling_libraries.R")
source(file = "Sampling_contamination.R")
source(file = "Sampling_plan.R")
source(file = "Sampling_outcome.R")
```

```{r}
sessionInfo()
```

2. List important parameters from `Sampling_contamination.R` and `Sampling_plan.R`. Create a new variable `n_sim`.

**Contamination:**  

  * `n_contam` = the number of contamination spots, which follows a Poisson distribution (`Pois(lambda = 3)`) 
  * `x_lim` = the limits of the horizontal axis  
  * `y_lim` = the limits of the vertical axis  
  * `x` = the horizontal coordinate of the contamination center, which follows a uniform distribution (`U(0,10)`)
  * `y` = the vertical coordinate of the contamination center, which follows a uniform distribution(`U(0,10)`)  

  **Mode 1: Discrete Spread** 

  * `n_affected` = the number of affected plants near the contamination spot, which follows a Poisson distribution (`Pois(lambda = 5)`)   
  * `covar_mat` = covariance matrix of `x` and `y`, which defines the spread of contamination. Assume the spread follows a 2D normal distribution with var(X) =     0.25, var(Y) = 0.25 and cov(X, Y) = 0  

  **Mode 2: Continuous Spread**

  * `spread_radius` = the radius of the contamination spread

**Sampling Plan:**  

  * `n_sp` = the number of sampling points
  * `sp_radius` = the radius (m) of a circular region around the sample point. (Only applicable to **Mode 1: Discrete Spread**)
  
**Iteration:**

  * `n_sim` = the number of simulations

```{r}
## Contamination
n_contam = rpois(n = 1, lambda = 3)
x_lim = c(0, 10)
y_lim = c(0, 10)

### Discrete spread
n_affected = rpois(n = 1, lambda = 5)
covar_mat = matrix(data = c(0.25, 0, 0, 0.25), nrow = 2, ncol = 2)

### Continuous spread
spread_radius = 2.5

## Sampling plan
n_sp = 10
sp_radius = 1

## Sampling outcome
n_sim = 10000
```

```{r}
n_contam
n_affected
```


3. Create a master function called `sim_outcome()` that takes the inputs above and outputs the rate of detection.

* Intermediate data output includes `contam_xy`, `sp_xy`, `contam_sp_xy`, `dist_contam_sp`, `cover_dis` and `cover_cont`.

```{r}
sim_outcome = function(n_contam, x_lim, y_lim, n_affected, covar_mat, spread_radius, n_sp, sp_radius, method){
  
  # Generate the coordinates of contamination points
  contam_xy = sim_contam(n_contam = n_contam, x_lim = x_lim, y_lim = y_lim, covariance = covar_mat, n_affected = n_affected, radius = spread_radius) 
  
  # Generate the coordinates of sample points
  sp_xy = sim_plan(n_sp = n_sp, x_lim = x_lim, y_lim = y_lim, r = sp_radius)
  
  # Generate the combined coordinates of contamination and sample points
  contam_sp_xy = rbind(contam_xy, sp_xy)
  rownames(contam_sp_xy) = NULL
  
  # Calculate the distance between sample points and contamination points
  dist_contam_sp = calc_dist(contam_sp_xy)
  
  # Determine whether contamination is detected and calculate ROD
  if(method == "discrete"){
    
    cover_dis = cover(df_dist = dist_contam_sp, df_coord = contam_sp_xy, r = sp_radius, method = method)
    calc_ROD(df_cover = cover_dis, df_contam = contam_xy, n_sp = n_sp, method = method)
    
  } else if (method == "continuous"){
    
    cover_cont = cover(df_dist = dist_contam_sp, df_coord = contam_sp_xy, r = spread_radius, method = method)
    calc_ROD(df_cover = cover_cont, df_contam = contam_xy, n_sp = n_sp, method = method)
    
  }
}

```

4. Create a function that iterates `sim_outcome()` and returns a vector of RODs.

```{r}
sim_iterate = function(n_sim, n_contam, x_lim, y_lim, n_affected, covar_mat, spread_radius, n_sp, sp_radius, method){
    
    # Initialize a numeric vector to store RODs
    ROD = vector(mode = "numeric", length = n_sim)
    
    # Iterate the simulation without parallelization
    for(i in 1:n_sim){
      ROD[i] = sim_outcome(
                  n_contam = n_contam,
                  x_lim = x_lim,
                  y_lim = y_lim,
                  n_affected = n_affected,
                  covar_mat = covar_mat,
                  spread_radius = spread_radius,
                  n_sp = n_sp,
                  sp_radius = sp_radius,
                  method = method
                )
    }
    
    return(ROD)
}
```

```{r}
# # Register (n-2) cores for parallelization
# cl = makeCluster(detectCores() - 2)
# registerDoParallel(cl)
# 
# # List the packages needed
# packages = c("dplyr", "MASS", "ggforce", "reshape2")
# 
# # Iterate the simulation with parallelization
# foreach(i = 1:n_sim, .combine = c, .packages = packages) %dopar%
#   sim_outcome(
#     n_contam = n_contam,
#     x_lim = x_lim,
#     y_lim = y_lim,
#     n_affected = n_affected,
#     covar_mat = covar_mat,
#     spread_radius = spread_radius,
#     n_sp = n_sp,
#     sp_radius = sp_radius,
#     method = "continuous"
#   )
# 
# # Stop the cores
# stopCluster(cl)
```

# Results

1. Run the simulation once and generate the rate of detection.

```{r}
# For debug or reproducibility only
# set.seed(123)

sim_outcome(n_contam = n_contam, x_lim = x_lim, y_lim = y_lim, n_affected = n_affected, covar_mat = covar_mat, spread_radius = spread_radius, n_sp = n_sp, sp_radius = sp_radius, method = "continuous")
```

2. Run the simulation for `r n_sim` times.

```{r}
ROD = sim_iterate(n_sim = n_sim, n_contam = n_contam, x_lim = x_lim, y_lim = y_lim, n_affected = n_affected, covar_mat = covar_mat, spread_radius = spread_radius, n_sp = n_sp, sp_radius = sp_radius, method = "continuous")
```

3. Boxplot of the rate of detection.

```{r}
ggplot() +
  stat_boxplot(aes(x = "Continuous", y = ROD), geom = "errorbar") +
  geom_boxplot(aes(x = "Continuous", y = ROD)) +
  geom_point(aes(x = "Continuous", y = mean(ROD)), color = "coral", shape = 4, size = 5) +
  labs(title = paste("n_contam = ", n_contam, ", n_sp = ", n_sp, ", n_sim = ", n_sim , sep = "")) +
  coord_fixed(ratio = 1, ylim = c(0,1)) +
  theme_bw()
```

4. For debug only

```{r, eval = FALSE}
# set.seed(123)
# 
#   # Generate the coordinates of contamination points
#   contam_xy = sim_contam(n_contam = n_contam, x_lim = x_lim, y_lim = y_lim, covariance = covar_mat, n_affected = n_affected, radius = spread_radius) 
#   
#   # Generate the coordinates of sample points
#   sp_xy = sim_plan(n_sp = n_sp, x_lim = x_lim, y_lim = y_lim, r = sp_radius)
#   
#   # Generate the combined coordinates of contamination and sample points
#   contam_sp_xy = rbind(contam_xy, sp_xy)
#   rownames(contam_sp_xy) = NULL
#   
#   # Calculate the distance between sample points and contamination points
#   dist_contam_sp = calc_dist(contam_sp_xy)
#   
#   # Determine whether contamination is detected and calculate ROD
#     
#   cover_dis = cover(df_dist = dist_contam_sp, df_coord = contam_sp_xy, r = sp_radius, method = "discrete")
#   calc_ROD(df_cover = cover_dis, df_contam = contam_xy, n_sp = n_sp, method = "discrete")
#   
#   cover_cont = cover(df_dist = dist_contam_sp, df_coord = contam_sp_xy, r = spread_radius, method = "continuous")
#   calc_ROD(df_cover = cover_cont, df_contam = contam_xy, n_sp = n_sp, method = "continuous")
    
```

